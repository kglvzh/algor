
# Построение матрицы смежности #

# Условия: количество вершин: 8; рёбра: (1,2), (2,3), (3,4), (4,1), (5,6), (7,8). 
# Алгоритм: 
# Матрица смежности — это квадратная матрица размера n x n (где n — количество вершин графа). 
# Элемент матрицы a[i][j] равен: - 1, если есть ребро между вершинами i и j; - 0, если ребра нет.

# Результат: матрица смежности для данного графа: 
#      1  2  3  4  5  6  7  8
#   1  0, 1, 0, 1, 0, 0, 0, 0
#   2  1, 0, 1, 0, 0, 0, 0, 0
#   3  0, 1, 0, 1, 0, 0, 0, 0
#   4  1, 0, 1, 0, 0, 0, 0, 0
#   5  0, 0, 0, 0, 0, 1, 0, 0
#   6  0, 0, 0, 0, 1, 0, 0, 0
#   7  0, 0, 0, 0, 0, 0, 0, 1
#   8  0, 0, 0, 0, 0, 0, 1, 0

# Пояснение:
# Ребро (1,2) → a[0][1] = 1 и a[1][0] = 1
# Ребро (2,3) → a[1][2] = 1 и a[2][1] = 1
# Ребро (3,4) → a[2][3] = 1 и a[3][2] = 1
# Ребро (4,1) → a[3][0] = 1 и a[0][3] = 1
# Ребро (5,6) → a[4][5] = 1 и a[5][4] = 1
# Ребро (7,8) → a[6][7] = 1 и a[7][6] = 1

def create_adjacency_matrix(edges, num_vertices):
    # Создаем матрицу размера num_vertices x num_vertices, заполненную нулями
    adjacency_matrix = [[0 for _ in range(num_vertices)] for _ in range(num_vertices)]
    
    # Заполняем матрицу: если есть ребро между вершинами u и v, ставим 1
    for edge in edges:
        u, v = edge
        adjacency_matrix[u - 1][v - 1] = 1
        adjacency_matrix[v - 1][u - 1] = 1  # Граф неориентированный
    
    return adjacency_matrix

# Задаем граф (список рёбер) и количество вершин
edges = [(1, 2), (2, 3), (3, 4), (4, 1), (5, 6), (7, 8)]
num_vertices = 8

# Создаем матрицу смежности
adjacency_matrix = create_adjacency_matrix(edges, num_vertices)

# Выводим матрицу смежности
print("Матрица смежности:")
for row in adjacency_matrix:
    print(row)

print('\n')

# Построение матрицы инцидентности #

# Условия: количество вершин: 8; количество рёбер: 6; рёбра: 1 - (1,2), 2 - (2,3), 3 - (3,4), 4 - (4,1), 5 - (5,6), 6 - (7,8). 
# Алгоритм: 
# Матрица инцидентности — это прямоугольная матрица размером n x m (где n — количество вершин, m — количество ребер).   
# Элемент матрицы b[i][j] равен: - 1, если вершина i инцидентна ребру j; - 0, если вершина i не инцидентна ребру j. 

# Результат: матрица инцидентности для данного графа:
#      1  2  3  4  5  6
#   1  1, 0, 0, 1, 0, 0
#   2  1, 1, 0, 0, 0, 0
#   3  0, 1, 1, 0, 0, 0
#   4  0, 0, 1, 1, 0, 0
#   5  0, 0, 0, 0, 1, 0
#   6  0, 0, 0, 0, 1, 0
#   7  0, 0, 0, 0, 0, 1
#   8  0, 0, 0, 0, 0, 1

# Пояснение:
# Ребро 1 (1,2), инцидентно вершинам 1 и 2 → b[0][0] = 1 и b[1][0] = 1
# Ребро 2 (2,3), инцидентно вершинам 2 и 3 → b[1][1] = 1 и b[2][1] = 1
# Ребро 3 (3,4), инцидентно вершинам 3 и 4 → b[2][2] = 1 и b[3][2] = 1
# Ребро 4 (4,1), инцидентно вершинам 4 и 1 → b[3][3] = 1 и b[0][3] = 1
# Ребро 5 (5,6), инцидентно вершинам 5 и 6 → b[4][4] = 1 и b[5][4] = 1
# Ребро 6 (7,8), инцидентно вершианм 7 и 8 → b[6][5] = 1 и b[7][5] = 1

def create_incidence_matrix(edges, num_vertices):
    # Количество рёбер
    num_edges = len(edges)
    
    # Создаем матрицу размера num_vertices x num_edges, заполненную нулями
    incidence_matrix = [[0 for _ in range(num_edges)] for _ in range(num_vertices)]
    
    # Заполняем матрицу: если вершина инцидентна ребру, ставим 1
    for edge_index, edge in enumerate(edges):
        u, v = edge
        incidence_matrix[u - 1][edge_index] = 1
        incidence_matrix[v - 1][edge_index] = 1  # Граф неориентированный
    
    return incidence_matrix

# Задаем граф (список рёбер) и количество вершин
edges = [(1, 2), (2, 3), (3, 4), (4, 1), (5, 6), (7, 8)]
num_vertices = 8

# Создаем матрицу инцидентности
incidence_matrix = create_incidence_matrix(edges, num_vertices)

# Выводим матрицу инцидентности
print("Матрица инцидентности:")
for row in incidence_matrix:
    print(row)

print('\n')

# Поиск компонент связности #

# Алгоритм: 
# Компоненты связности графа определяются с помощью обхода графа: 
# - Используем алгоритм поиска в глубину (DFS). 
# - Начинаем с любой непосещённой вершины, отмечаем ее посещённой и переходим к её соседям. 
# - Если все соседи обработаны, начинаем с другой непосещённой вершины (если существует), что означает начало новой компоненты связности.

# Шаги:
# 1. Начинаем с вершины 1: 
# - DFS обходит вершины 1 → 2 → 3 → 4. 
# - Первая компонента связности: {1, 2, 3, 4}. 
# 2. Ищем непосещённые вершины: 
# - Вершины 5 6 7 8 не были посещены → начинаем новую компоненту, посещаем вершину 5.
# - DFS обходит вершины 5 → 6. 
# - Вторая компонента связности: {5, 6}.
# 3. Ищем оставшиеся непосещённые вершины: 
# - Вершины 7 8 не были посещены → начинаем новую компоненту, посещаем вершину 7.
# - DFS обходит вершины 7 → 8. 
# - Третья компонента связности: {7, 8}.

# Результат: компоненты связности графа: 
# 1: {1, 2, 3, 4} 
# 2: {5, 6} 
# 3: {7, 8}

def find_connected_components(adjacency_matrix):
    num_vertices = len(adjacency_matrix)
    visited = [False] * num_vertices
    components = []

    def dfs(vertex, current_component):
        visited[vertex] = True
        current_component.append(vertex + 1)  # Вершина хранится с индексом +1
        for neighbor, is_connected in enumerate(adjacency_matrix[vertex]):
            if is_connected and not visited[neighbor]:
                dfs(neighbor, current_component)

    # Запускаем поиск компонент
    for vertex in range(num_vertices):
        if not visited[vertex]:
            current_component = []
            dfs(vertex, current_component)
            components.append(current_component)

    return components

# Находим компоненты связности
connected_components = find_connected_components(adjacency_matrix)

# Выводим результат
print("\nКомпоненты связности графа:")
for i, component in enumerate(connected_components, start=1):
    print(f"Компонента {i}: {component}")

# Пояснение кода:
# 1. create_adjacency_matrix: создаёт матрицу смежности для заданного графа. 
# 2. create_incidence_matrix: создаёт матрицу инцидентности для заданного графа. 
# 3. find_connected_components: использует алгоритм поиска в глубину (DFS) для определения компонент связности графа. 
# 4. В конце выводим матрицы и список компонент связности.